/* 
 * Talon.One API
 *
 * Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 
 *
 * 
 * Contact: devs@talon.one
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = TalonOne.Client.OpenAPIDateConverter;

namespace TalonOne.Model
{
    /// <summary>
    /// NewPriceAdjustment
    /// </summary>
    [DataContract]
    public partial class NewPriceAdjustment :  IEquatable<NewPriceAdjustment>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NewPriceAdjustment" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected NewPriceAdjustment() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NewPriceAdjustment" /> class.
        /// </summary>
        /// <param name="priceType">The price type (e.g. the price for members only) to apply to a given SKU. (required).</param>
        /// <param name="price">The value of the price type applied to the SKU. When set to &#x60;null&#x60;, the defined price type no longer applies to the SKU..</param>
        /// <param name="referenceId">A unique reference identifier, e.g. a UUID. (required).</param>
        /// <param name="calculatedAt">The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided..</param>
        /// <param name="effectiveFrom">The date and time from which the price adjustment is effective..</param>
        /// <param name="effectiveUntil">The date and time until which the price adjustment is effective..</param>
        /// <param name="contextId">Identifier of the context of this price adjustment (e.g. summer sale)..</param>
        public NewPriceAdjustment(string priceType = default(string), decimal? price = default(decimal?), string referenceId = default(string), DateTime calculatedAt = default(DateTime), DateTime effectiveFrom = default(DateTime), DateTime effectiveUntil = default(DateTime), string contextId = default(string))
        {
            // to ensure "priceType" is required (not null)
            this.PriceType = priceType ?? throw new ArgumentNullException("priceType is a required property for NewPriceAdjustment and cannot be null");
            // to ensure "referenceId" is required (not null)
            this.ReferenceId = referenceId ?? throw new ArgumentNullException("referenceId is a required property for NewPriceAdjustment and cannot be null");
            this.Price = price;
            this.CalculatedAt = calculatedAt;
            this.EffectiveFrom = effectiveFrom;
            this.EffectiveUntil = effectiveUntil;
            this.ContextId = contextId;
        }
        
        /// <summary>
        /// The price type (e.g. the price for members only) to apply to a given SKU.
        /// </summary>
        /// <value>The price type (e.g. the price for members only) to apply to a given SKU.</value>
        [DataMember(Name="priceType", EmitDefaultValue=false)]
        public string PriceType { get; set; }

        /// <summary>
        /// The value of the price type applied to the SKU. When set to &#x60;null&#x60;, the defined price type no longer applies to the SKU.
        /// </summary>
        /// <value>The value of the price type applied to the SKU. When set to &#x60;null&#x60;, the defined price type no longer applies to the SKU.</value>
        [DataMember(Name="price", EmitDefaultValue=true)]
        public decimal? Price { get; set; }

        /// <summary>
        /// A unique reference identifier, e.g. a UUID.
        /// </summary>
        /// <value>A unique reference identifier, e.g. a UUID.</value>
        [DataMember(Name="referenceId", EmitDefaultValue=false)]
        public string ReferenceId { get; set; }

        /// <summary>
        /// The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.
        /// </summary>
        /// <value>The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.</value>
        [DataMember(Name="calculatedAt", EmitDefaultValue=false)]
        public DateTime CalculatedAt { get; set; }

        /// <summary>
        /// The date and time from which the price adjustment is effective.
        /// </summary>
        /// <value>The date and time from which the price adjustment is effective.</value>
        [DataMember(Name="effectiveFrom", EmitDefaultValue=false)]
        public DateTime EffectiveFrom { get; set; }

        /// <summary>
        /// The date and time until which the price adjustment is effective.
        /// </summary>
        /// <value>The date and time until which the price adjustment is effective.</value>
        [DataMember(Name="effectiveUntil", EmitDefaultValue=false)]
        public DateTime EffectiveUntil { get; set; }

        /// <summary>
        /// Identifier of the context of this price adjustment (e.g. summer sale).
        /// </summary>
        /// <value>Identifier of the context of this price adjustment (e.g. summer sale).</value>
        [DataMember(Name="contextId", EmitDefaultValue=false)]
        public string ContextId { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NewPriceAdjustment {\n");
            sb.Append("  PriceType: ").Append(PriceType).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  ReferenceId: ").Append(ReferenceId).Append("\n");
            sb.Append("  CalculatedAt: ").Append(CalculatedAt).Append("\n");
            sb.Append("  EffectiveFrom: ").Append(EffectiveFrom).Append("\n");
            sb.Append("  EffectiveUntil: ").Append(EffectiveUntil).Append("\n");
            sb.Append("  ContextId: ").Append(ContextId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as NewPriceAdjustment);
        }

        /// <summary>
        /// Returns true if NewPriceAdjustment instances are equal
        /// </summary>
        /// <param name="input">Instance of NewPriceAdjustment to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NewPriceAdjustment input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.PriceType == input.PriceType ||
                    (this.PriceType != null &&
                    this.PriceType.Equals(input.PriceType))
                ) && 
                (
                    this.Price == input.Price ||
                    (this.Price != null &&
                    this.Price.Equals(input.Price))
                ) && 
                (
                    this.ReferenceId == input.ReferenceId ||
                    (this.ReferenceId != null &&
                    this.ReferenceId.Equals(input.ReferenceId))
                ) && 
                (
                    this.CalculatedAt == input.CalculatedAt ||
                    (this.CalculatedAt != null &&
                    this.CalculatedAt.Equals(input.CalculatedAt))
                ) && 
                (
                    this.EffectiveFrom == input.EffectiveFrom ||
                    (this.EffectiveFrom != null &&
                    this.EffectiveFrom.Equals(input.EffectiveFrom))
                ) && 
                (
                    this.EffectiveUntil == input.EffectiveUntil ||
                    (this.EffectiveUntil != null &&
                    this.EffectiveUntil.Equals(input.EffectiveUntil))
                ) && 
                (
                    this.ContextId == input.ContextId ||
                    (this.ContextId != null &&
                    this.ContextId.Equals(input.ContextId))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.PriceType != null)
                    hashCode = hashCode * 59 + this.PriceType.GetHashCode();
                if (this.Price != null)
                    hashCode = hashCode * 59 + this.Price.GetHashCode();
                if (this.ReferenceId != null)
                    hashCode = hashCode * 59 + this.ReferenceId.GetHashCode();
                if (this.CalculatedAt != null)
                    hashCode = hashCode * 59 + this.CalculatedAt.GetHashCode();
                if (this.EffectiveFrom != null)
                    hashCode = hashCode * 59 + this.EffectiveFrom.GetHashCode();
                if (this.EffectiveUntil != null)
                    hashCode = hashCode * 59 + this.EffectiveUntil.GetHashCode();
                if (this.ContextId != null)
                    hashCode = hashCode * 59 + this.ContextId.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // ReferenceId (string) minLength
            if(this.ReferenceId != null && this.ReferenceId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ReferenceId, length must be greater than 1.", new [] { "ReferenceId" });
            }

            yield break;
        }
    }

}
